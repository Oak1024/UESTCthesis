% !Mode:: "TeX:UTF-8"

\chapter{软件设计}
\section{本章简介}
本章主要通过线程管理、软件流程、配置脚本解释器、lua脚本四个部分系统地介绍了本系统的软件构架。线程管理部分是系统级的软件，属于软件部分的中层，描述了各个线程间的关系与通信方式。软件流程则是描述了各个线程各自的软件流程，直观地解释了线程的工作机制。解释器与lua脚本部分属于应用层，是系统中的最上层。解释器部分介绍了一个自制的脚本解释器的实现，lua脚本部分则是演示了一个本系统的插件开发的例子，通过这个例子可以体现出本系统的插件开发的便利性。

\section{线程管理}
RT-Thread中的任务根据内存特性被称为线程，因此RT-Thread的开发主要是线程功能与线程间通信的开发。
\subsection{线程功能介绍}
\begin{enumerate}
\item USBhost接口监测线程

USB协议栈庞大而复杂，需要单独开辟线程进行维护。此线程根据USB状态，定时对USBhost接口上的数据进行处理，读取USB键盘的数据。

\item  MCU间通信线程

这个线程主要用于处理两个单片机之间的通信问题。由于两个单片机的任务不同，程序结构差异较大，所以需要专门开启一个线程，与作为USBdev接口的单片机进行通信，发送与接收U盘的读写、键盘的按键信息。

\item FLASH控制线程

由于两个单片机共用一个FLASH芯片，而且读写FLASH需要的时间较长，因此需要使用一个线程用来监测通信接口的IO信号，对FLASH进行相应读写操作。

\item  应用层线程

由于应用层实现的功能较多，所以需要单独使用线程进行维护。这个线程主要用来初始化应用层程序，对配置文件进行语法分析并执行。



\end{enumerate}




\subsection{线程间通信量、同步量}
\begin{enumerate}
\item 消息序列1

USBhost接口线程通过此消息序列将USB信息传递给应用层线程，同时此消息序列还用做存储按键的FIFO。
\item 消息序列2

应用层线程通过此消息学咧将USB信息传递给通信线程，同时此消息序列还用做存储按键的FIFO。
\item 信号量1

用于FLASH读写的同步，保证至多一个线程在操作FLASH芯片。
\item 信号量2

用于通信线程与FLASH控制线程间的同步。
\end{enumerate}


\section{软件流程}
\subsection{USB接口监测线程}
\pic[h]{USB接口监测线程流程图}{}{liu1}
USB接口线程在开机后便初始化，初始化完成后不断对USB信息的进行读取。一旦读取到USB传来的有效信息，就将其打包后发送给应用层线程。

\subsection{通信线程}
\pic[h]{通信线程流程图}{}{liu2}
如图\ref{liu2}所示，通信线程首先通过IO口操作和USB接口单片机进行通信，然后阻塞在消息序列的等待上。一旦收到消息，便根据具体情况把消息发送给接口单片机。

\subsection{应用层控制线程}
\pic[h]{应用层线程流程图}{}{liu4}
如图\ref{liu4}所示，应用层线程在启动后会使用FATFS对FLASH内的脚本文件进行一次读取。读取后通过自制的语法分析器进行分析，并生成相应的过滤器链表。之后此进程阻塞在按键消息的等待上，并处理得到的按键消息。

\section{信息流向}
\pic[h]{信息流程示意图}{}{liu5}
如图\ref{liu5}所示，USB信息从USB母头传至USB公头共经历3个FIFO。信息从母头进入后首先被USB接口线程检测到，经过打包后发入第一个FIFO。此时阻塞在此FIFO的线程——应用层线程就绪并执行，根据FLASH中脚本内容进行过滤并执行脚本内容，将脚本对应的按键根据脚本规则发入第二个FIFO。此时阻塞在第二个FIFO的通信线程就绪并执行，将收到的信息打包发给USB接口单片机。USB接口单片机中通过环结构对外界信息进行存储，在端点空闲后将信息发送给电脑。

\section{配置脚本分析}
本设计的脚本使用精简版的AHK脚本语言（暂命名为BMK 语言）。目前可以实现复杂快捷键过滤、发送长名称键、语法错误分析等功能。
\subsection{快捷键语法介绍}
\verb|BMK语言的快捷键过滤器部分使用不常用的四个符号代替具体快捷键"ctrl"-'^' ,"win"-'#',"alt"-'^',"shift"-'+'。通过这几个符号可以代替快捷键全称，极大地简化了脚本的编写。另外，使用'>'和'<'符号来确定快捷键的左右方向，缺省值为双向。'<'为仅限左边的键，'>'为仅限右边的键。例如："<+>!q"即为左shift+右alt键+q组合快捷键。|

\subsection{快捷键语法介绍}
\verb|一个完整的BMK脚本是由脚本段组成的。每个脚本段由三部分构成：1快捷键过滤器，2双冒号分隔符，3：按键脚本。示例：>!n::{down}。意为按下右alt+n 快捷键，可以发送给PC“down”键（即向下箭头）（这个语法段是emacs的一个快捷键操作）。|

每个语法段中的三个部分缺一不可，每部分都有各自的作用。
\begin{enumerate}
\item 快捷键过滤器

抓取快捷键，提供脚本执行情景。

\item 双冒号分隔符

分割过滤器与按键脚本，防止混杂出现语法错误。

\item 按键脚本

作为脚本的执行部分，必不可少。

\item 其他

\verb|使用';'为行开头可以进行注释，不区分大小写|。
\end{enumerate}

\verb|按键脚本中，普通按键直接书写相应ASCii码作为表示。长按键如“TAB”、“SPACE”等，使用大括号括起表示，如“{tab}”|。

\subsection{配置脚本解释器器简介}

本课题的解释器是自主研发的，约700行，分为分段器、语法分析器、token分析器三部分。



\subsubsection{  分段器}

分段器将程序脚本根据0x0A标志分为多个语法段，并去掉相应的0x0D标志。每个程序段构成一个独立的语法段落，实现一个独立的快捷键过滤并执行脚本的功能。

\subsubsection{ 语法分析器}

语法分析器将token分析器得到的token序列进行分析，并在程序段结束时对整个程序段进行注册。语法分析器可以根据token序列的具体内容，判断语法的正确与否。比如在声明一组快捷键过滤器后又进行了一组快捷键的声明，这时会提示快捷键声明重复。

\subsubsection{  token分析器}

token分析器将分段器分出的程序段看做纯ASCii序列，然后整理成token流。token分析器将token分为单侧控制键、双侧控制键、其他键、脚本键等几种，并根据分析器的状态和当前ASCii码将ASCii流根据情况整理为token流。分析器还可以发现错误token，生成提示。


\subsection{快捷键配置代码}
这段代码的作用是将右CTRL与n,p,f,b,a等键组合而成的快捷键映射为方向键等光标控制键，实现了全局的emacs快捷键模拟。最后一行以分号结尾，是注释。写明了控制键的符号与含义的对应关系。
\input{chapters/MODE_1.asm.tex}

\subsection{语法分析器核心代码}
\verb|这段代码是整个解释器的最核心部分——语法分析器，负责将token分析器得到的token进行分析并解释。配置脚本通过分段器进行分段，然后传入mode_line_process函数。函数的第一个参数是存放整个配置脚本的指针，第二个参数则是本段的开始和结束的相对于整个配置脚本的位置。|

程序首先判断行开头是否是分号，如果是分号则认为本段是注释，直接返回。如果不是分号，则逐步通过token分析器得到token，再根据token的类型进行判断与配置。如果遇到非法的语法，则通过串口输出函数进行警告输出。
\input{chapters/s.c.tex}


\section{lua脚本}

这是一段示例程序，存放在系统的板上FLASH中。

这段程序共有4个函数：

\begin{enumerate}
\item \verb|key_handle|

处理到捕获的按键数据，
\item \verb|macro_play|

重放捕获到的按键数据。

\item \verb|macro_end|

捕获结束标志置位。

\item \verb|macro_start|

捕获到宏录制快捷键后执行，判断是宏录制的开始还是结束，然后调用相应函数。

\end{enumerate}

这段程序首先将所有函数保存为数组，便于后期调用。然后将第三个和第四个函数元素注册到相应快捷键。之后进入循环，等待快捷键触发，配合C语言函数触发后，根据得到的返回值调用相应函数，从而实现宏录制的功能。

\input{chapters/profile.lua.tex}





